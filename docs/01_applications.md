# アプリケーションとその構成

前章でも説明した通り、今回のアプリケーションは `bff` や `main` といった複数の Rails アプリケーションから成り立っています。
それぞれの Rails アプリケーションについて概要を説明します。

## Backend For Frontend (BFF)

`bff` はその名の通り、[Backend For Frontend (BFF)](https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html) の役割をするアプリケーションです。

Backend For Frontend とは、iOS や Android や Web などのアプリケーションに対して、
UI を構成するために必要な情報を様々なバックエンドから取得し、組み立てて返すものです。

![https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html から引用](https://philcalcado.com/img/2015-09-back-end-for-front-end-pattern/sc-bff-6.png)
（https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html から引用）

Backend For Frontend は例えば次のような目的で導入されます。

- iOS, Android, Web などそれぞれで必要とするデータの形式や構造に特化する
- バックエンドのマイクロサービス化に伴う複雑性をバックエンド側で吸収する
- クライアント<->サーバ間の通信回数の増大を抑える

BFF についてのより詳細な解説は、https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html や https://samnewman.io/patterns/architectural/bff/ などを参照してください。

クックパッドにも Java で書かれた Orcha という BFF があります。Orcha の技術選定や登場の背景については https://techlife.cookpad.com/entry/2019-orcha-bff を参照してください。

今回の `bff` アプリケーションは、`bff/config/routes.rb` にある通り、次のようなエンドポイントを持ちます。
( https://railsguides.jp/routing.html )

- GET: `/v1/users/:id`
- GET/POST/DELETE: `/v1/users`
- GET: `/v1/recipes/:id`
- GET/POST/DELETE: `/v1/recipes`

各エンドポイントでは、gRPC を用いて `main` サービスと通信した結果を返しています。

## gRPC と Protocol Buffers

### gRPC

`bff` と `main` 間の通信では、[gRPC](https://grpc.io) が用いられています。

gRPC はオープンソースのハイパフォーマンスな RPC (Remote Procedure Call) フレームワークで、様々な言語・プラットフォームで利用することが可能です。
（RPC とは、ネットワーク上にある他のコンピュータ上でプログラムを呼び出す手法のこと）

gRPC では、クライアントが Stub を利用してサーバ側のメソッドを呼ぶと、それが透過的にサーバへのリクエストとして実際に発行されます。
リクエストを受けたサーバは、クライアントが呼び出したメソッドを実行し、その結果をクライアントに返します。

![https://grpc.io/docs/guides/#overview から引用](https://grpc.io/img/landing-2.svg)
（https://grpc.io/docs/guides/#overview から引用）

gRPC では IDL (Interface Definition Language) として [Protocol Buffers](https://developers.google.com/protocol-buffers) を利用することができます。
（IDL は、インターフェースを記述するための言語で、gRPC ではクライアント・サーバ間でやり取りするメソッド名、メソッドの引数・返り値、データの構造などを IDL を用いて定義する）

クックパッドでも実際のサービスで gRPC を利用しています。クックパッドでの実際の gRPC の導入や背景などは https://logmi.jp/tech/articles/320715 も参照してください。

### Protocol Buffers

Protocol Buffers には、データ構造と、RPC メソッドのパラメータと返り値を定義します。
例えば、`id` と `name` というプロパティを持つ User は次のように定義できます。

```protobuf
syntax = "proto3";

message User {
    uint64 id = 1;
    string name = 2;
}
```

この User を、`page`, `per_page` パラメータを受け取り、
User のリストで返すような `ListUsers` の RPC 定義は次のように定義できます。

```protobuf
syntax = "proto3";

package main.services.v1;

import "main/resources/v1/user.proto";

service User {
    rpc ListUsers(ListUsersRequest) returns (ListUsersResponse) {}
}

message ListUsersRequest {
    uint32 page = 1;
    uint32 per_page = 2;
}

message ListUsersResponse {
    repeated User users = 1;
}
```

gRPC は、このような Protocol Buffers の定義からサーバ・クライアントのコードを自動生成できます。
Ruby であれば、次のようなコマンドで生成することができます。

```sh
$ bundle exec grpc_tools_ruby_protoc -I ./examples --ruby_out=examples/lib --grpc_out=examples/lib ./examples/user.proto
```

message として定義したものが `user_pb.rb` として生成され、service として定義したものが `user_services_pb.rb` として生成されます。

- `user_pb.rb`

```ruby
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: user.proto

require 'google/protobuf'

Google::Protobuf::DescriptorPool.generated_pool.build do
  add_file("user.proto", :syntax => :proto3) do
    add_message "UserResource" do
      optional :id, :uint64, 1
      optional :name, :string, 2
    end
    add_message "ListUsersRequest" do
      optional :page, :uint32, 1
      optional :per_page, :uint32, 2
    end
    add_message "ListUsersResponse" do
      repeated :users, :message, 1, "UserResource"
    end
  end
end

UserResource = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("UserResource").msgclass
ListUsersRequest = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("ListUsersRequest").msgclass
ListUsersResponse = ::Google::Protobuf::DescriptorPool.generated_pool.lookup("ListUsersResponse").msgclass
```

- `user_services_pb.rb`

```ruby
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# Source: user.proto for package ''

require 'grpc'
require 'user_pb'

module UserService
  class Service

    include GRPC::GenericService

    self.marshal_class_method = :encode
    self.unmarshal_class_method = :decode
    self.service_name = 'UserService'

    rpc :ListUsers, ListUsersRequest, ListUsersResponse
  end

  Stub = Service.rpc_stub_class
end
```

### protobuf-definitions

今回のアプリケーションの Protocol Buffers の定義は `protobuf-definitions` ディレクトリ以下にあります。
`main` というディレクトリ以下は次のようになっていて、`resources` 以下に各リソースの定義、`services` 以下に RPC の定義が置かれています。

```bash
$ tree
.
└── main
    ├── resources
    │   └── v1
    │       ├── ingredient.proto
    │       ├── recipe.proto
    │       ├── step.proto
    │       └── user.proto
    └── services
        └── v1
            ├── recipe.proto
            └── user.proto

```

`bff`, `main` などそれぞれのサービスで `protobuf-definitions` の proto 定義から、
Ruby のコードを生成できる Rake task を用意してあります。`main` の proto 定義からコードを生成したい場合は、次のようにします。

```sh
bundle exec rake 'protobuf:compile[main]'
```

`bff`, `main` など各アプリケーションでこの定義から生成されたコードを利用するため、proto 定義を更新した場合は関係するアプリケーション全てでコード生成を行うようにしましょう。

### gRPC サーバの実装

実際に gRPC サーバである `main` の実装を見ていきましょう。
`main` では [Griffin](https://github.com/cookpad/griffin) という Gem を利用して gRPC サーバを起動しています。

Griffin の設定は `main/config/initializers/griffin.rb` に書いてあります。
`services` の中に実際の実装が書かれているクラスが配列で入っています。

```ruby
Griffin::Server.configure do |c|
  # :
  c.services([
    RecipeService,
    UserService,
  ])
  # :
end
```

`RecipeService` や `UserService` は `main/app/services/` の中で定義されています。
`UserService` では `protobuf-definitions/main/services/v1/user.proto` から生成された、
`user_services_pb` に定義されている `Main::Services::V1::User::Service` を継承しています。

このようなクラスの中に、Protocol Buffers の `service` で定義したメソッド名を実装することで、
クライアントからの呼び出しが行われた際に実行されることになります。

```ruby
require 'main/services/v1/user_services_pb'

class UserService < Main::Services::V1::User::Service
  def list_users(request, call)
    page = request.page unless request.page.zero?
    per_page = request.per_page unless request.per_page.zero?

    users = User.
      order(created_at: :desc).
      page(page).
      per(per_page)

    Main::Services::V1::ListUsersResponse.new(
      users: users.map(&:as_protocol_buffer)
    )
  rescue ActiveRecord::RecordNotFound => e
    raise GRPC::NotFoundss.new(e.message)
  end
```

## 実際に実装してみる

実際に、`bff` の `/v1/users/:id` を HTTP GET すると、`bff` が `main` に gRPC 呼び出しを行い、結果を返すまでを実装してみましょう。

まずは、`protobuf-definitions` で id を指定して User を取得する、`GetUser` rpc を定義してみましょう。

```
$EDITOR protobuf-definitions/main/services/v1/user.proto
```

`GetUser` rpc に用いる `GetUserRequest`, `GetUserResponse` のデータ構造を定義します。
`id` (`uint64`) を受け取ってそのユーザを返すため、Request のデータ構造は次のようになります。

```protobuf
message GetUserRequest {
    uint64 id = 1;
}
```

レスポンスは単一の `User` を返すため、次のようになります。

```protobuf
message GetUserResponse {
    main.resources.v1.User user = 1;
}
```

実際の `GetUser` の定義は、次のようになります。

```protobuf
service User {
    rpc GetUser(GetUserRequest) returns (GetUserResponse) {}
}
```

定義が書けたら、`bff` 側の実装に移ります。proto を変更したので、まずはコード生成をします。

```bash
pushd bff
bundle
bundle exec rake 'protobuf:compile[main]'
popd
```

次に、クライアント部分を書きます。

```sh
$EDITOR bff/app/controllers/v1/users_controller.rb
```

次のように、まずは request に用いる GetUserRequest のインスタンスを生成します。

```ruby
request = Main::Services::V1::GetUserRequest.new(id: params[:id].to_i)
```

次に、`main` の User service に対する stub を作成し、
引数として先程の `request` を渡しながら `get_user` メソッドを呼び出します。

```
MainGrpcClient.stub(:user).get_user(request)
```

このメソッドを呼び出すことで、内部的には gRPC を用いて `main` に実装されている `get_user` メソッドを呼び出すことができます。

`users_controller.rb` の最終的な diff は次のようになります。

```diff
 module V1
   class UsersController < ApplicationController
     def show
+      request = Main::Services::V1::GetUserRequest.new(id: params[:id].to_i)
+      begin
+        response = MainGrpcClient.stub(:user).get_user(request)
+      rescue GRPC::NotFound
+        return render status: 404
+      end
+
+      render json: response
-      # TODO: implement
     end
```

次に、`main` 側の実装に移ります。

```sh
$EDITOR main/app/services/user_service.rb
```

サーバ側の `get_user` では第一引数に `request` が渡ってきます。この `request` はここでは `GetUserRequest` の型になっているはずです。

`request.id` によって DB から User を探し、存在すればそのユーザを `GetUserResponse` のインスタンスで返し、存在しなければ `GRPC::NotFound` を返す、という実装になります。

```ruby
 class UserService < Main::Services::V1::User::Service
   def get_user(request, call)
     user = User.find(request.id)
     user_as_protocol_buffer = Main::Resources::V1::User.new(
         id: id,
         name: name,
         created_at: Google::Protobuf::Timestamp.new.tap {|t| t.from_time(created_at) },
         updated_at: Google::Protobuf::Timestamp.new.tap {|t| t.from_time(updated_at) },
       )

     Main::Services::V1::GetUserResponse.new(
       user: user_as_protocol_buffer
     )
```

このように、特定のモデルを `Main::Resources::V1::User` のような Protobuf から生成されたクラスに変換するコードは頻繁に発生するため、`main/app/models/user.rb` の中に `as_protocol_buffer` というメソッドを定義してあります。

```ruby
  def as_protocol_buffer(request_context: nil)
    Main::Resources::V1::User.new(
      id: id,
      name: name,
      created_at: Google::Protobuf::Timestamp.new.tap {|t| t.from_time(created_at) },
      updated_at: Google::Protobuf::Timestamp.new.tap {|t| t.from_time(updated_at) },
    )
  end
```

これを利用して、最終的な `main` の `get_user` のコードは次のようになります。

```diff
 class UserService < Main::Services::V1::User::Service
   def get_user(request, call)
+    user = User.find(request.id)
+
+    Main::Services::V1::GetUserResponse.new(
+      user: user.as_protocol_buffer
+    )
+  rescue ActiveRecord::RecordNotFound => e
+    raise GRPC::NotFound.new(e.message)
-    # TODO: implement
   end
```
